# -*- coding: utf-8 -*-
"""is practicals.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ezZFDO7_HqYAsviBinIvEWJk0q1gR6fl

#Euclidean
"""

#EUCLIDEAN
def gcd(a, b):
  if b == 0:
    return a
  else:
    return gcd(b, (a % b))

gcd(50,65)

def extended(a,b):
  r=a%b
  s=[1,0]
  t=[0,1]
  i=2
  while(r!=0):
    q=a//b
    s.append(s[i-2]-q*s[i-1])
    t.append(t[i-2]-q*t[i-1])
    i+=1

    r=a%b
    a=b
    b=r

  return abs(s[-2]*a+b*t[-2])

extended(161,28)

"""#VERNAM CIPEHR

"""

a=[]
for i in range(26):
  a.append(chr(i+65))
print(a)

pt='HELLO'
key='DGHBC'
ptvalue=[]
keyvalue=[]
for j in pt:
    if j in a:
      ptvalue.append(a.index(j))

for j in key:
    if j in a:
      keyvalue.append(a.index(j))
print(ptvalue)
print(keyvalue)

ctvalue=[]
for i in range(len(ptvalue)):
  ctvalue.append((ptvalue[i]+keyvalue[i])%26)
print(ctvalue )

ct=''
for i in ctvalue:
  ct+=a[i]
ct

"""#Ceaser cipher"""

alow=[]
for i in range(26):
  alow.append(chr(97 + i))
ahigh=[]
for i in range(26):
  ahigh.append(chr(65 + i))
print(alow)
print(ahigh)

def encryption(s, key):
    encrypt= ''

    for char in s:
        if char in alow:
            index =( alow.index(char)+key)%26
            encrypt+=alow[index]
        elif char in ahigh:
            index = (ahigh.index(char)+key)%26
            encrypt+=ahigh[index]
        else:
            encrypt+=char
    return encrypt

text=input("PLain Text: ")
key=int(input('Enter the key: '))
result=encryption(text, key)
print("Cipher Text",result)

def decryption(result,key):
  return encryption(result,-key)

plain=decryption(result,key)
print(plain)

"""#railfence

"""

key=3
pt="hello world"
row=key
col=len(pt)
matrix=[]
for i in range(row):
  a=[]
  for j in range(col):
    a.append("")
  matrix.append(a)

dir_down = False
row, col = 0, 0

for i in range(len(pt)):
        if (row == 0) or (row == key - 1):
            dir_down = not dir_down

        matrix[row][col] = pt[i]
        col += 1

        if dir_down:
            row += 1
        else:
            row -= 1

ct=''
print('Rail fence')
for i in range(key):
  print(matrix[i])

for i in range(key):
        for j in range(len(pt)):
                ct+=matrix[i][j]
print(f"cipher text:{ct}")

#decryp

"""#transposition

"""

import math
pt = "wearediscoveredsaveyourself"
key = [4, 3, 2, 1, 7, 5, 6]
row = int(math.ceil(len(pt)/len(key)))
col = len(key)
matrix=[]
count=0
keysort = sorted(list(key))

for i in range(row):
    matrix.append([])
    for j in range(col):
        if count<len(pt) :
          matrix[i].append(pt[count])
          count+=1
        else:
          matrix[i].append('x')

for i in matrix:
    print(i)
ct=''

for j in keysort:
  for i in range(row):
    ct+=matrix[i][key.index(j)]
ct
print("Cipher text")
cipher = ct.replace('x','')
cipher

"""###decrpt

"""

import math

key = [4, 3, 2, 1, 7, 5, 6]

row = int(math.ceil(len(ct) / len(key)))
col = len(key)
matrix = []
keysort = sorted(list(key))
count = 0

for i in range(row):
    matrix.append([])
    for j in range(col):
        if count < len(ct):
            matrix[i].append(ct[count])
            count += 1
        else:
            matrix[i].append('x')

mat=[]
for i in range(row):
  a=[]
  for j in range(col):
    a.append(' ')
  mat.append(a)


index=0
for j in keysort:
  for i in range(row):
    if index<len(ct):
      mat[i][key.index(j)]=ct[index]
      index+=1

print("decypt matrix:")
for i in matrix:
    print(i)

print("encyp matrix:")
for i in mat:
    print(i)

decrypted_text = ''
for i in range(row):
  for j in range(col):
    decrypted_text+=mat[i][j]

decrypted_text=decrypted_text.replace("x",'')
print("\nDecrypted Text:")
print(decrypted_text)

"""#playfair

"""

key='MONARCHY'
pt = 'INSTRUMENTS'
alpha=''
for i in range(26):
  alpha+=(chr(65 + i))
alpha=alpha.replace('J','')

keytemp=key
for i in alpha:
  if i not in keytemp:
    keytemp+=i

count=0
matrix=[]
for i in range(5):
    matrix.append([])
    for j in range(5):
        if count<len(keytemp) :
          matrix[i].append(keytemp[count])
          count+=1

pairs = []
def makepair(word):
    for i in range(0, len(word), 2):
        pair = word[i:i+2]
        pairs.append(pair)

    if len(word) % 2 == 1:
        pairs[-1] += 'X'


makepair(pt)

pairs

def find_position(matrix, letter):
    for i in range(5):
        for j in range(5):
            if matrix[i][j] == letter:
                return i, j

def playfair_cipher(matrix, pairs):
    cipher_text = ''
    for pair in pairs:
        row1, col1 = find_position(matrix, pair[0])
        row2, col2 = find_position(matrix, pair[1])

        # Same row
        if row1 == row2:
            cipher_text += matrix[row1][(col1 + 1) % 5] + matrix[row2][(col2 + 1) % 5]
        # Same column
        elif col1 == col2:
            cipher_text += matrix[(row1 + 1) % 5][col1] + matrix[(row2 + 1) % 5][col2]
        # Different row and column
        else:
            cipher_text += matrix[row1][col2] + matrix[row2][col1]

    return cipher_text

print("Playfair Matrix:")
for row in matrix:
    print(row)

cipher_text = playfair_cipher(matrix, pairs)
print("\nPlaintext:", pt)
print("Encrypted Text:", cipher_text)

"""###decipher"""

pairs=[]
def makepair(word):
    for i in range(0, len(word), 2):
        pair = word[i:i+2]
        pairs.append(pair)

    if len(word) % 2 == 1:
        pairs[-1] += 'X'


makepair(cipher_text)
def playfair_decipher(matrix, pairs):
    decrypted_text = ''
    for pair in pairs:
        row1, col1 = find_position(matrix, pair[0])
        row2, col2 = find_position(matrix, pair[1])

        # Same row
        if row1 == row2:
            decrypted_text += matrix[row1][(col1 - 1) % 5] + matrix[row2][(col2 - 1) % 5]
        # Same column
        elif col1 == col2:
            decrypted_text += matrix[(row1 - 1) % 5][col1] + matrix[(row2 - 1) % 5][col2]
        # Different row and column
        else:
            decrypted_text += matrix[row1][col2] + matrix[row2][col1]

    return decrypted_text

decrypted_text = playfair_decipher(matrix, pairs)
decrypted_text=decrypted_text.replace("X",'')
print("\nEncrypted Text:", cipher_text)
print("Decrypted Text:", decrypted_text)

"""#RSA"""

import math
def gcd(a, b):
	temp = 0
	while(1):
		temp = a % b
		if (temp == 0):
			return b
		a =b
		b = temp

p = 3
q = 7
n = p*q
e = 2
phi = (p-1)*(q-1)

while (e < phi):
	if(gcd(e, phi) == 1):
		break
	else:
		e = e+1

k = 2
d = (1 + (k*phi))/e

msg = 12.0

print("Message data = ", msg)

c = pow(msg, e)
c = c%n
print("Encrypted data = ", c)

m = pow(c, d)
m = m%n
print("Original Message Sent = ", m)

"""#RSA digital signature

"""

def extended(a,b):
  r=a%b
  s=[1,0]
  t=[0,1]
  i=2
  while(r!=0):
    q=a//b
    s.append(s[i-2]-q*s[i-1])
    t.append(t[i-2]-q*t[i-1])
    i+=1

    r=a%b
    a=b
    b=r

  return t[-2]

p,q,e=7,11,13
n=p*q
phi=(p-1)*(q-1)

d= extended(phi,e)
if d<0:
  d+=phi
d

publickey=[e,n]
privatekey=[d,n]
pt=17

ct=(17**e) % n
print("Cipher text",ct)

decryption=(ct**d) % n
print("original text",decryption)

"""#Deffie hellman"""

# Diffie-Hellman Code

def prime_checker(p):
	# Checks If the number entered is a Prime Number or not
	if p < 1:
		return -1
	elif p > 1:
		if p == 2:
			return 1
		for i in range(2, p):
			if p % i == 0:
				return -1
			return 1


def primitive_check(g, p, L):
	# Checks If The Entered Number Is A Primitive Root Or Not
	for i in range(1, p):
		L.append((g**i) % p)
	for i in range(1, p):
		if L.count(i) > 1:
			L.clear()
			return -1
		return 1


l = []
while 1:
	P = int(input("Enter P : "))
	if prime_checker(P) == -1:
		print("Number Is Not Prime, Please Enter Again!")
		continue
	break

while 1:
	G = int(input(f"Enter The Primitive Root Of {P} : "))
	if primitive_check(G, P, l) == -1:
		print(f"Number Is Not A Primitive Root Of {P}, Please Try Again!")
		continue
	break

# Private Keys
x1, x2 = int(input("Enter The Private Key Of User 1 : ")), int(input("Enter The Private Key Of User 2 : "))
while 1:
	if x1 >= P or x2 >= P:
		print(f"Private Key Of Both The Users Should Be Less Than {P}!")
		continue
	break

# Calculate Public Keys
y1, y2 = pow(G, x1) % P, pow(G, x2) % P

# Generate Secret Keys
k1, k2 = pow(y2, x1) % P, pow(y1, x2) % P

print(f"\nSecret Key For User 1 Is {k1}\nSecret Key For User 2 Is {k2}\n")

if k1 == k2:
	print("Keys Have Been Exchanged Successfully")
else:
	print("Keys Have Not Been Exchanged Successfully")
print(l)

print("ENTER PRIME NUMBER\n")
p = int(input("Enter value of p:"))

g = int(input("Enter A primitive root of p:"))

a = int(input("Enter value of a:"))
b = int(input("Enter value of b:"))

x1,x2  = g**a % p,g**b % p
print("X=", x1)
print("Y =", x2)

k1,k2 = x2**a % p,x1**b % p
print("k1 =", k1)
print("k2 =", k2)

"""#Man in Middle"""

print("ENTER PRIME NUMBER\n")
#p = int(input("Enter value of p:"))
p=227
#g = int(input("Enter A primitive root of p:"))
q=14
#a = int(input("Enter key of alice:"))
a=227
#b = int(input("Enter key of bob:"))
b=170

d1,d2=65,175
print("\nDarth selects 65 for alice  and  175 for bob")

x1,x2  = g**a % p,g**b % p
print("\nAlice published=", x1)
print("Bob published=", x2)

d1shared=g**d1%p
d2shared=g**d2%p
print("\nDarth publish pk for alice",d1shared)
print("Darth publish pk for bob",d2shared)

k1=d1shared**a % p
dk1 = x1**d1 % p
print("\nAlice computed =", k1)
print("Darth computed=",dk1)

k2=d2shared**b % p
dk2= x2**d2 % p
print("\nbob computed =", k2)
print("Darth computed=",dk2)

